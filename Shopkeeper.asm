;SOME INSTRUCTIONS:
; 1.FIRST GIVE PRICE NAME AND PRESS TAB
; 2.THEN GIVE PRICE AND PRESS TAB
; 3. THE PROCESS WILL KEEP GOING UNTIL ENTER HAS BEEN PRESSED

INCLUDE 'EMU8086.INC'
.MODEL SMALL
.STACK 200H  
 
.DATA

    ITEM_COUNT DB 0 ; COUNTING HOW MANY INPUTS WE ARE GIVING
    ITEM DB  400 DUP(?) ; considering each item name is of 20 characters max and it can store max 20 names
    PRICE DW 20 DUP(?)  ; MAXIMUM PRICE OF A SINGLE ITEM CAN BE 2559
    N DW 0; FOR DECIAML I/P O/P
 
    NAME_IDX_OFFSET DB 20 ; AS ALL THE NAMES STARTING INDEXES ARE 20 SLOTS AWAY
    ITEM_COUNT_IDX DB 0  ;FOR OFFSETTING INDEX FOR NAME ARRAY
    NAME_PRINT_COUNTER DB 0 ; MAKING SURE 20 CHARACTERS ARE PRINTING AT A TIME
    PRICE_IDX DW 0 ; WILL BE USED FOR INDEXING PRICES DURING BUBBLE SORTING
    INITIAL_NAME_SWAPPING_IDX DW 0 ; WILL BE USED FOR CHARACTERS SWAPPING IN BUBBLE SORTING
    FINAL_NAME_SWAPPING_IDX DW 0   ; WILL BE USED FOR CHARACTERS SWAPPING IN BUBBLE SORTING
    BUBBLE_SORT_COUNT DB 0 ;
 
    KEY DW 20                ; KEY FOR BINARY SEARCHING
 
.CODE 
    MAIN PROC
    MOV AX, @DATA
    MOV DS, AX
    
    PRINTN "SOME INSTRUCTIONS: "
    PRINTN "   1.FIRST GIVE PRICE NAME AND PRESS TAB"
    PRINTN "   2.THEN GIVE PRICE AND PRESS TAB. " 
    PRINTN "   3. PRESS ANOTHER TAB TO START INPUTTING NEW ITEM"
    PRINTN "   4. THE PROCESS WILL KEEP GOING UNTIL ENTER HAS BEEN PRESSED"
    
    ;//////////////////START OF INPUT SECTION////////////////////////////
    XOR SI,SI
    
    NAME_IP:
        XOR DI,DI
        XOR AX,AX
        XOR BL,BL
    
        MOV AL,ITEM_COUNT
        MOV BL,NAME_IDX_OFFSET
        MUL BL    ; AX=20 X ITEM COUNT
        MOV DI,AX ; DI = 20 X ITEM COUNT + INDEX
    
    
    TAKING_NAME_IP:
        MOV AH,1
        INT 21H
        CMP AL,09H
        JE EXIT_TAKING_NAME_IP
        MOV ITEM[DI],AL
        INC DI
        JMP TAKING_NAME_IP
    
    EXIT_TAKING_NAME_IP:
    
    
    TAKING_PRICE_IP:
        CALL DECIMAL_INPUT
        MOV BX,N
        ;XOR BH,BH
        MOV PRICE[SI],BX
        ADD SI,2
        INC ITEM_COUNT
        
    TAKING_ANOTHER_NAME_IP:
       MOV AH,1
       INT 21H
       CMP AL,0DH ; CHECKING IF ENTER HAS BEEN PRESSED OR NOT. WILL STOP TAKING INPUT
       JE EXIT_TAKING_PRICE_IP
       CMP AL,09H ; CHECKING IF TAB IS PRESSED OR NOT. WILL START TAKING ANOTHER ITEM
       PRINTN
       JE NAME_IP
        
    ;//////////////////END OF INPUT TAKING//////////////////////
    EXIT_TAKING_PRICE_IP:
   
    ;//////////////START OF BUBBLE SORTING//////////////////
    START_BUBBLE_SORT:
        XOR CX,CX
        MOV CL,BUBBLE_SORT_COUNT
        CMP CL,ITEM_COUNT
        JG EXIT_BUBBLE_SORT
        
        XOR SI,SI
        XOR DI,DI
        XOR CX,CX; CLEARING ALL THE REGISTERS FIRST
        XOR BX,BX
        XOR DX,DX
        XOR AX,AX
        MOV ITEM_COUNT_IDX,BL ; INITIATING ITEM_CONT_IDX=0
        MOV PRICE_IDX,BX      ; INITIATING PRICE_IDX =0
    
    OUTER_LOOP:
        XOR DH,DH
        MOV DH,ITEM_COUNT
        SUB DH,1
        CMP ITEM_COUNT_IDX,DH    
        JE EXIT_OUTER_LOOP ; THIS OUTER LOOP HAS TO RUN ONE LESS TIME THAN NUMBER OF ITEMS AS INPUT
        
        MOV SI,PRICE_IDX ; SI WILL TRACK FIRST ELEMENT
        MOV DI,SI
        ADD DI,2         ; DI WILL TRACK THE NEXTV ELEMENT OF THE BUBBLE
        
        MOV BX,PRICE[DI] ; TEMPORARY STORING FOR COMPARING IN NEXT LINE
        CMP PRICE[SI],BX
        JG NEEDS_EXCHANGE
        JMP EXIT_NEEDS_EXCHANGE ; IF NO SWAP NEEDED
        
        NEEDS_EXCHANGE:
            XOR BX,BX
            MOV BX,PRICE[DI] ; TEMPORARY STORING FOR EXCHANGING IN NEXT LINE
            XCHG PRICE[SI],BX
            MOV PRICE[DI],BX
            
            XOR SI,SI;CLEARING FOR NAME SWAP
            XOR DI,DI
            
            NAME_SWAP:
                MOV AL,ITEM_COUNT_IDX
                XOR CH,CH
                MOV CL,20 ; AS ALL THE NAMES ARE 20 CHARACTERS APPART
                MUL CL    ; AX=ITEM_COUNT_IDX X 20 
                MOV INITIAL_NAME_SWAPPING_IDX ,AX ; NOW IT HAS THE INITIAL SWAPPING POSITION
                
                XOR AL,AL
                MOV AL,ITEM_COUNT_IDX
                INC AL      ; TRYING TO GET THE NEXT SET OF CHAARCTERS OF NEXT ITEM
                XOR CL,CL
                MOV CL,20   ; AS ALL THE NAMES ARE 20 CHARACTERS APPART 
                MUL CL      ; AX= AX= (ITEM_COUNT_IDX+1) X 20 
                MOV FINAL_NAME_SWAPPING_IDX ,AX ; NOW IT HAS THE FINAL SWAPPING POSITION
                
                MOV SI,INITIAL_NAME_SWAPPING_IDX   ;SI NOW HAS STARTING INDEX OF FIRST NAME 
                MOV DI,FINAL_NAME_SWAPPING_IDX ,AX ;DI NOW HAS STARTING INDEX OF 2ND NAME
                
                XOR CX,CX
                MOV CX,20
                SWAP_LOOP:
                    XOR BL,BL
                    MOV BL,ITEM[DI] ;FOR TEMPORARY STORAGE FOR SWAPPING
                    XCHG ITEM[SI],BL
                    MOV ITEM[DI],BL
                    INC SI
                    INC DI
                
                LOOP SWAP_LOOP ; WILL RUN FOR 20 TIMES
        
        EXIT_NEEDS_EXCHANGE:
            INC ITEM_COUNT_IDX
            ADD PRICE_IDX,2
            JMP OUTER_LOOP
   
    EXIT_OUTER_LOOP:
        INC BUBBLE_SORT_COUNT
        JMP START_BUBBLE_SORT
    
    EXIT_BUBBLE_SORT:
    ;///////////////////////////END OF BUBBLE SORTING/////////////////////////////////
   
    ;//////////////////////////PRINTING SORTED OUTPUTS//////////////////////////////////
    PRINTN
    PRINTN
    PRINTN "SORTED OUTPUT: "
    PRINT "ITEM NAME         PRICE"
    XOR SI,SI
    XOR CX,CX
    MOV CL,ITEM_COUNT ; STORING NUMBER OF ITEMS IN CX FOR RUNNNG THIS NUMBER OF TIMES THE LOOP
    XOR CH,CH
    XOR AX,AX
    MOV ITEM_COUNT_IDX,AL ; INITIATING ITEM_CONT_IDX=0  
   
    PRINTING:
        MOV BL,ITEM_COUNT_IDX
        CMP BL,ITEM_COUNT ; CHECKING IF NUMBER OF ITEMS TO BE PRINTED IS EXCEEDING TOTAL AMOUNT OF STORED ITEM OR NOT
        JGE EXIT_PRINTING
   
        PRINTN 
        XOR DI,DI
        XOR BX,BX
        MOV NAME_PRINT_COUNTER,BL ; SETTING NAME_PRINT_COUNTER=0 EVERYTIME BEFORE STARTING OF PRINTING ANY NAME. WILL VARY BETWEEN 0 TO 19                                         
            
        MOV AL,ITEM_COUNT_IDX ; TRACKING HOW MANY ITEMS HAVE BEEN PRINTED
        MOV BL,NAME_IDX_OFFSET ; BL=20
        MUL BL    ; AX=20 X ITEM COUNT
        MOV DI,AX ; DI = 20 X ITEM COUNT INDEX + INDEX       
   
    PRINT_NAME:
        CMP NAME_PRINT_COUNTER,19
        JG PRINT_PRICE 
        MOV AH,2
        MOV DL,ITEM[DI]
        INT 21H
        INC DI
        INC NAME_PRINT_COUNTER
        JMP PRINT_NAME
    
   
   
    PRINT_PRICE:
        MOV AX,PRICE[SI]
        ;XOR AH,AH         ;NOW AX HAS THE FULL PRICE
        CALL DECIMAL_OUTPUT
        ADD SI,2
        INC ITEM_COUNT_IDX
        JMP PRINTING
    
    
    EXIT_PRINTING:
   
 ;///////////////////////////END OF PRINTING SORTED OUTPUT////////////////////////////////////////////
 
 ;TAKING INPUT OF KEY FOR BINARY SEARCHING
    ;PRINTN
    ;PRINTN
    ;PRINT "ENTER THE KEY PRICE ABOVE WHICH YOU WANT TO SEE THE ITEMS AND PRESS TAB: "
    ;CALL DECIMAL_INPUT
    ;MOV BX,N
    ;MOV KEY,BX
 
 ;//////////////////////////START OF BIANRY SEARCHING//////////////////////////////////////////////
 
    XOR BX,BX                 ;
    MOV ITEM_COUNT_IDX,BL     ; MAKING ITEM_COUNT_IDX=0
    MOV PRICE_IDX,BX          ; MAKING PRICE_IDX=0
    MOV NAME_PRINT_COUNTER,BL ; MAKING NAME_PRINT_COUNTER=0
 
    ; FINDING SEARCH START INDEX
 
    MOV AL,ITEM_COUNT
    XOR AH,AH
    MOV BL,2           ;WE WANT TO DIVIDE BY 2
    DIV BL             ; HERE WE DID ITEM_COUNT/2 . QUOTIENT IS IN AL
    MUL BL;             QUOTIENT X 2 . AS WE TOOK WORD SIZE ARRAY. INDEX IS IN AX
    
    ; START TRAVERSING     
    MOV SI,AX      ;AX has the initial traversing index
 
    XOR BX,BX
    MOV BX,PRICE[SI]
    CMP BX,KEY
    JG REVERSE_TRAVERSE
 
    FORWARD_TRAVERSE: ;IF PRICE [SI] <= KEY
        XOR BX,BX
        MOV BX,PRICE[SI] 
        CMP BX,KEY
        JLE FORWARD_TRAVERSE_CONTINUE
 
    JMP EXIT_TRAVERSE ; IF PRICE [SI] GETS GREATER THAN KEY
    
    FORWARD_TRAVERSE_CONTINUE:
        ADD SI,2
        JMP FORWARD_TRAVERSE
        
    REVERSE_TRAVERSE:
        XOR BX,BX
        MOV BX,PRICE[SI] 
        CMP BX,KEY
        JG REVERSE_TRAVERSE_CONTINUE
        ADD SI,2;IF PRICE [SI] GETS EQUAL OR SMALLER THAN  THE KEY IT WILL INCREMENT AND STRAT FROM NEXT VALUE WHICH IS GREATER THAN KEY        
        JMP EXIT_TRAVERSE
        
    REVERSE_TRAVERSE_CONTINUE:    
        SUB SI,2
        JMP REVERSE_TRAVERSE     
 
    EXIT_TRAVERSE: ; STARTING PRICE INDEX IS IN SI NOW
 
    MOV PRICE_IDX,SI   ;NOW PRICE_IDX WILL CONTAIN INITIAL ITEM'S PRICE WITH PRICE > 20 
 
    XOR AX,AX
    MOV AX,SI ; WE WILL DIVIDE PRICE_IDX BY 2 TO GET INITIAL NAME INDEX FOR ITEM WITH PRICE > 20
    XOR BL,BL
    MOV BL,2
    DIV BL    ;NOW AL HAS THE DESIRED STARING NAME INDEX
    MOV ITEM_COUNT_IDX,AL
    
    ;///////////////////PRINTING VALUES GREATER THAN THE KEY/////////////////////////////////////////////
 
     ;NOW WE WILL USE SAME STATEMENTS FOR PRINTING NAME WHICH WERE USED IN PREVIOUS PRINTING SECTION
     PRINTN
     PRINTN
     PRINTN "ITEMS WITH PRICE GREATER THAN KEY(20 DOLLARS):"
     XOR SI,SI
     XOR CX,CX
     MOV CL,ITEM_COUNT ; STORING NUMBER OF ITEMS IN CX FOR RUNNNG THIS NUMBER OF TIMES THE LOOP
     XOR CH,CH
    
    PRINTING2:
       MOV BL,ITEM_COUNT_IDX
       CMP BL,ITEM_COUNT ; CHECKING IF NUMBER OF ITEMS TO BE PRINTED IS EXCEEDING TOTAL AMOUNT OF STORED ITEM OR NOT
       JGE EXIT_PRINTING2
   
       PRINTN
       
       MOV AL,ITEM_COUNT_IDX ; TRACKING HOW MANY ITEMS HAVE BEEN PRINTED
       MOV BL,NAME_IDX_OFFSET ; BL=20
       MUL BL    ; AX=20 X ITEM COUNT
       MOV DI,AX ; DI = 20 X ITEM COUNT INDEX + INDEX
       XOR CX,CX
       MOV CX,20    ;FOR PRINTING 20 CHARACTERS OF A NAME
       NAME_PRINT2:
            MOV AH,2
            MOV DL,ITEM[DI]
            INT 21H
            INC DI
       LOOP NAME_PRINT2
       INC ITEM_COUNT_IDX 
       JMP PRINTING2
    EXIT_PRINTING2:
    
    MOV AH,4CH
    INT 21H  
    MAIN ENDP

;/////////////////////////////////////DEFINED FUNCTIONS///////////////////////////////////////////////
DECIMAL_INPUT PROC
    
    MOV N,0
    MOV BL,10
    
    INPUT:
    MOV AH,1
    INT 21H
    CMP AL,09H
    JE END_INPUT
    SUB AL,48
    MOV AH,0; WORKING WITH FULL AX
    MOV CX,AX ;CX NOW HAS THE TAKEN INPUT
    MOV AX,N ;AX HAS THE OLD DIGITS(FULL NUMBER)
    MUL BL
    ADD AX,CX ;AX HAS NOW THE FULL NEW NUMBER
    MOV N,AX ; N HAS THE FULL NEW NUMBER
    JMP INPUT
    
    END_INPUT:
    RET
    
DECIMAL_INPUT ENDP

DECIMAL_OUTPUT PROC
    MOV DX,0
    MOV BX,10
    MOV CX,0  ; WORKING AS COUNTER
    
    L1:
    DIV BX   ;DIVIDING AX(FULL NUMBER) BY 10. AX HAS THE QUOTIENT
    PUSH DX  ; DX HAS THE LAST DIGIT.PUSHED TO STACK
    MOV DX,0
    MOV AH,0
    INC CX
    CMP AX,0  ;CHECKING IF QUOTIENT HAS BECOME 0 OR NOT
    JNE L1
    MOV AH,2
    
    L2:
    POP DX
    XOR DH,DH
    ADD DL,48
    INT 21H
    LOOP L2
    
    RET
    
DECIMAL_OUTPUT ENDP

ENDP